#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class RteReturnValue:
  """
  ************************************************************
   Global structures/defines                                  *
  ************************************************************
  """
  SUCCESS = 0
  QUALIFIED = 1
  ARGINVALID = 2
  IOERROR = 3
  MEMORYERROR = 4
  FILEIOERROR = 5
  NOTLOADED = 6
  HWINCOMPATIBLE = 7

  _VALUES_TO_NAMES = {
    0: "SUCCESS",
    1: "QUALIFIED",
    2: "ARGINVALID",
    3: "IOERROR",
    4: "MEMORYERROR",
    5: "FILEIOERROR",
    6: "NOTLOADED",
    7: "HWINCOMPATIBLE",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS": 0,
    "QUALIFIED": 1,
    "ARGINVALID": 2,
    "IOERROR": 3,
    "MEMORYERROR": 4,
    "FILEIOERROR": 5,
    "NOTLOADED": 6,
    "HWINCOMPATIBLE": 7,
  }

class RteValueType:
  Invalid = 0
  Int64 = 1
  String = 2

  _VALUES_TO_NAMES = {
    0: "Invalid",
    1: "Int64",
    2: "String",
  }

  _NAMES_TO_VALUES = {
    "Invalid": 0,
    "Int64": 1,
    "String": 2,
  }

class LogLevel:
  """
  ************************************************************
   Defines for general functions                              *
  ************************************************************
  """
  Unknown = 0
  Disable = 1
  Fatal = 2
  Error = 3
  Warn = 4
  Info = 5
  Debug = 6
  Extra = 7
  Heavy = 8

  _VALUES_TO_NAMES = {
    0: "Unknown",
    1: "Disable",
    2: "Fatal",
    3: "Error",
    4: "Warn",
    5: "Info",
    6: "Debug",
    7: "Extra",
    8: "Heavy",
  }

  _NAMES_TO_VALUES = {
    "Unknown": 0,
    "Disable": 1,
    "Fatal": 2,
    "Error": 3,
    "Warn": 4,
    "Info": 5,
    "Debug": 6,
    "Extra": 7,
    "Heavy": 8,
  }

class RegisterType:
  Invalid = 0
  Global = 1
  Direct = 2
  Static = 3

  _VALUES_TO_NAMES = {
    0: "Invalid",
    1: "Global",
    2: "Direct",
    3: "Static",
  }

  _NAMES_TO_VALUES = {
    "Invalid": 0,
    "Global": 1,
    "Direct": 2,
    "Static": 3,
  }

class P4CounterType:
  """
  ************************************************************
   Structure for Counters                                     *
  ************************************************************
  """
  Invalid = 0
  Global = 1
  Direct = 2
  Static = 3

  _VALUES_TO_NAMES = {
    0: "Invalid",
    1: "Global",
    2: "Direct",
    3: "Static",
  }

  _NAMES_TO_VALUES = {
    "Invalid": 0,
    "Global": 1,
    "Direct": 2,
    "Static": 3,
  }

class MeterType:
  """
  ************************************************************
   Meters                                                     *
  ************************************************************
  """
  Invalid = 0
  Global = 1
  Direct = 2
  Static = 3

  _VALUES_TO_NAMES = {
    0: "Invalid",
    1: "Global",
    2: "Direct",
    3: "Static",
  }

  _NAMES_TO_VALUES = {
    "Invalid": 0,
    "Global": 1,
    "Direct": 2,
    "Static": 3,
  }

class MeterClass:
  Invalid = 0
  Packets = 1
  Bytes = 2

  _VALUES_TO_NAMES = {
    0: "Invalid",
    1: "Packets",
    2: "Bytes",
  }

  _NAMES_TO_VALUES = {
    "Invalid": 0,
    "Packets": 1,
    "Bytes": 2,
  }


class RteReturn:
  """
  Attributes:
   - value
   - reason
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'value', None, None, ), # 1
    (2, TType.STRING, 'reason', None, None, ), # 2
  )

  def __init__(self, value=None, reason=None,):
    self.value = value
    self.reason = reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.reason = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RteReturn')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 1)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    if self.reason is not None:
      oprot.writeFieldBegin('reason', TType.STRING, 2)
      oprot.writeString(self.reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RteValue:
  """
  Attributes:
   - type
   - stringval
   - intval
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRING, 'stringval', None, None, ), # 2
    (3, TType.I64, 'intval', None, None, ), # 3
  )

  def __init__(self, type=None, stringval=None, intval=None,):
    self.type = type
    self.stringval = stringval
    self.intval = intval

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stringval = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.intval = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RteValue')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.stringval is not None:
      oprot.writeFieldBegin('stringval', TType.STRING, 2)
      oprot.writeString(self.stringval)
      oprot.writeFieldEnd()
    if self.intval is not None:
      oprot.writeFieldBegin('intval', TType.I64, 3)
      oprot.writeI64(self.intval)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DesignLoadArgs:
  """
  ************************************************************
   Structure for design load/unload/reload                    *
  ************************************************************

  Attributes:
   - nfpfw
   - pif_design_json
   - pif_config_json
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'nfpfw', None, None, ), # 1
    (2, TType.STRING, 'pif_design_json', None, None, ), # 2
    (3, TType.STRING, 'pif_config_json', None, None, ), # 3
  )

  def __init__(self, nfpfw=None, pif_design_json=None, pif_config_json=None,):
    self.nfpfw = nfpfw
    self.pif_design_json = pif_design_json
    self.pif_config_json = pif_config_json

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.nfpfw = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pif_design_json = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pif_config_json = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DesignLoadArgs')
    if self.nfpfw is not None:
      oprot.writeFieldBegin('nfpfw', TType.STRING, 1)
      oprot.writeString(self.nfpfw)
      oprot.writeFieldEnd()
    if self.pif_design_json is not None:
      oprot.writeFieldBegin('pif_design_json', TType.STRING, 2)
      oprot.writeString(self.pif_design_json)
      oprot.writeFieldEnd()
    if self.pif_config_json is not None:
      oprot.writeFieldBegin('pif_config_json', TType.STRING, 3)
      oprot.writeString(self.pif_config_json)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.nfpfw is None:
      raise TProtocol.TProtocolException(message='Required field nfpfw is unset!')
    if self.pif_design_json is None:
      raise TProtocol.TProtocolException(message='Required field pif_design_json is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DesignLoadStatus:
  """
  Attributes:
   - is_loaded
   - uuid
   - frontend_build_date
   - frontend_source
   - frontend_version
   - uptime
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_loaded', None, None, ), # 1
    (2, TType.STRING, 'uuid', None, None, ), # 2
    (3, TType.STRING, 'frontend_build_date', None, None, ), # 3
    (4, TType.STRING, 'frontend_source', None, None, ), # 4
    (5, TType.STRING, 'frontend_version', None, None, ), # 5
    (6, TType.I64, 'uptime', None, None, ), # 6
  )

  def __init__(self, is_loaded=None, uuid=None, frontend_build_date=None, frontend_source=None, frontend_version=None, uptime=None,):
    self.is_loaded = is_loaded
    self.uuid = uuid
    self.frontend_build_date = frontend_build_date
    self.frontend_source = frontend_source
    self.frontend_version = frontend_version
    self.uptime = uptime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_loaded = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.uuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.frontend_build_date = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.frontend_source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.frontend_version = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.uptime = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DesignLoadStatus')
    if self.is_loaded is not None:
      oprot.writeFieldBegin('is_loaded', TType.BOOL, 1)
      oprot.writeBool(self.is_loaded)
      oprot.writeFieldEnd()
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRING, 2)
      oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    if self.frontend_build_date is not None:
      oprot.writeFieldBegin('frontend_build_date', TType.STRING, 3)
      oprot.writeString(self.frontend_build_date)
      oprot.writeFieldEnd()
    if self.frontend_source is not None:
      oprot.writeFieldBegin('frontend_source', TType.STRING, 4)
      oprot.writeString(self.frontend_source)
      oprot.writeFieldEnd()
    if self.frontend_version is not None:
      oprot.writeFieldBegin('frontend_version', TType.STRING, 5)
      oprot.writeString(self.frontend_version)
      oprot.writeFieldEnd()
    if self.uptime is not None:
      oprot.writeFieldBegin('uptime', TType.I64, 6)
      oprot.writeI64(self.uptime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_loaded is None:
      raise TProtocol.TProtocolException(message='Required field is_loaded is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RegisterArrayArg:
  """
  ************************************************************
   Structure for Register                                     *
  ************************************************************

  Attributes:
   - reg_id
   - index
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reg_id', None, None, ), # 1
    (2, TType.I32, 'index', None, None, ), # 2
    (3, TType.I32, 'count', None, None, ), # 3
  )

  def __init__(self, reg_id=None, index=None, count=None,):
    self.reg_id = reg_id
    self.index = index
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reg_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RegisterArrayArg')
    if self.reg_id is not None:
      oprot.writeFieldBegin('reg_id', TType.I32, 1)
      oprot.writeI32(self.reg_id)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 2)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 3)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RegisterFieldDesc:
  """
  Attributes:
   - name
   - width
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'width', None, None, ), # 2
  )

  def __init__(self, name=None, width=None,):
    self.name = name
    self.width = width

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.width = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RegisterFieldDesc')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I32, 2)
      oprot.writeI32(self.width)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RegisterDesc:
  """
  Attributes:
   - name
   - id
   - type
   - count
   - table
   - tableid
   - fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'id', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
    (4, TType.I32, 'count', None, None, ), # 4
    (5, TType.STRING, 'table', None, None, ), # 5
    (6, TType.I32, 'tableid', None, None, ), # 6
    (7, TType.LIST, 'fields', (TType.STRUCT,(RegisterFieldDesc, RegisterFieldDesc.thrift_spec)), None, ), # 7
  )

  def __init__(self, name=None, id=None, type=None, count=None, table=None, tableid=None, fields=None,):
    self.name = name
    self.id = id
    self.type = type
    self.count = count
    self.table = table
    self.tableid = tableid
    self.fields = fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.tableid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.fields = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = RegisterFieldDesc()
            _elem5.read(iprot)
            self.fields.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RegisterDesc')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 2)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 4)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 5)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tableid is not None:
      oprot.writeFieldBegin('tableid', TType.I32, 6)
      oprot.writeI32(self.tableid)
      oprot.writeFieldEnd()
    if self.fields is not None:
      oprot.writeFieldBegin('fields', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter6 in self.fields:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class P4CounterDesc:
  """
  Attributes:
   - name
   - id
   - type
   - count
   - table
   - tableid
   - width
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'id', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
    (4, TType.I32, 'count', None, None, ), # 4
    (5, TType.STRING, 'table', None, None, ), # 5
    (6, TType.I32, 'tableid', None, None, ), # 6
    (7, TType.I32, 'width', None, None, ), # 7
  )

  def __init__(self, name=None, id=None, type=None, count=None, table=None, tableid=None, width=None,):
    self.name = name
    self.id = id
    self.type = type
    self.count = count
    self.table = table
    self.tableid = tableid
    self.width = width

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.tableid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.width = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('P4CounterDesc')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 2)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 4)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 5)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tableid is not None:
      oprot.writeFieldBegin('tableid', TType.I32, 6)
      oprot.writeI32(self.tableid)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I32, 7)
      oprot.writeI32(self.width)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SysCounterValue:
  """
  Attributes:
   - name
   - id
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'id', None, None, ), # 2
    (3, TType.STRUCT, 'value', (RteValue, RteValue.thrift_spec), None, ), # 3
  )

  def __init__(self, name=None, id=None, value=None,):
    self.name = name
    self.id = id
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.value = RteValue()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SysCounterValue')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 2)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 3)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class P4CounterReturn:
  """
  Attributes:
   - data
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'data', None, None, ), # 1
    (2, TType.I32, 'count', None, None, ), # 2
  )

  def __init__(self, data=None, count=None,):
    self.data = data
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('P4CounterReturn')
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 1)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 2)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableEntry:
  """
  ************************************************************
   Structure for Table Entry Modification                     *
  ************************************************************

  Attributes:
   - rule_name
   - default_rule
   - match
   - actions
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'rule_name', None, None, ), # 1
    (2, TType.BOOL, 'default_rule', None, None, ), # 2
    (3, TType.STRING, 'match', None, None, ), # 3
    (4, TType.STRING, 'actions', None, None, ), # 4
    (5, TType.I32, 'priority', None, None, ), # 5
  )

  def __init__(self, rule_name=None, default_rule=None, match=None, actions=None, priority=None,):
    self.rule_name = rule_name
    self.default_rule = default_rule
    self.match = match
    self.actions = actions
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.rule_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.default_rule = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.match = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.actions = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableEntry')
    if self.rule_name is not None:
      oprot.writeFieldBegin('rule_name', TType.STRING, 1)
      oprot.writeString(self.rule_name)
      oprot.writeFieldEnd()
    if self.default_rule is not None:
      oprot.writeFieldBegin('default_rule', TType.BOOL, 2)
      oprot.writeBool(self.default_rule)
      oprot.writeFieldEnd()
    if self.match is not None:
      oprot.writeFieldBegin('match', TType.STRING, 3)
      oprot.writeString(self.match)
      oprot.writeFieldEnd()
    if self.actions is not None:
      oprot.writeFieldBegin('actions', TType.STRING, 4)
      oprot.writeString(self.actions)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 5)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.rule_name is None:
      raise TProtocol.TProtocolException(message='Required field rule_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableDesc:
  """
  Attributes:
   - tbl_id
   - tbl_name
   - tbl_entries_max
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tbl_id', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I32, 'tbl_entries_max', None, None, ), # 3
  )

  def __init__(self, tbl_id=None, tbl_name=None, tbl_entries_max=None,):
    self.tbl_id = tbl_id
    self.tbl_name = tbl_name
    self.tbl_entries_max = tbl_entries_max

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tbl_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.tbl_entries_max = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableDesc')
    if self.tbl_id is not None:
      oprot.writeFieldBegin('tbl_id', TType.I32, 1)
      oprot.writeI32(self.tbl_id)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.tbl_entries_max is not None:
      oprot.writeFieldBegin('tbl_entries_max', TType.I32, 3)
      oprot.writeI32(self.tbl_entries_max)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tbl_id is None:
      raise TProtocol.TProtocolException(message='Required field tbl_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class McastCfgEntry:
  """
  ************************************************************
   Multicast Group Configuration                              *
  ************************************************************

  Attributes:
   - group_id
   - max_entries
   - ports
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'group_id', None, None, ), # 1
    (2, TType.I32, 'max_entries', None, None, ), # 2
    (3, TType.LIST, 'ports', (TType.I32,None), None, ), # 3
  )

  def __init__(self, group_id=None, max_entries=None, ports=None,):
    self.group_id = group_id
    self.max_entries = max_entries
    self.ports = ports

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.group_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max_entries = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.ports = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readI32();
            self.ports.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('McastCfgEntry')
    if self.group_id is not None:
      oprot.writeFieldBegin('group_id', TType.I32, 1)
      oprot.writeI32(self.group_id)
      oprot.writeFieldEnd()
    if self.max_entries is not None:
      oprot.writeFieldBegin('max_entries', TType.I32, 2)
      oprot.writeI32(self.max_entries)
      oprot.writeFieldEnd()
    if self.ports is not None:
      oprot.writeFieldBegin('ports', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.ports))
      for iter13 in self.ports:
        oprot.writeI32(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PortInfo:
  """
  ************************************************************
   Port information                                            *
  ************************************************************

  Attributes:
   - id
   - token
   - info
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.STRING, 'token', None, None, ), # 2
    (3, TType.STRING, 'info', None, None, ), # 3
  )

  def __init__(self, id=None, token=None, info=None,):
    self.id = id
    self.token = token
    self.info = info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.info = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PortInfo')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 2)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.info is not None:
      oprot.writeFieldBegin('info', TType.STRING, 3)
      oprot.writeString(self.info)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ParserValueSetFieldDesc:
  """
  ************************************************************
   Structure for Parser Value Sets                            *
  ************************************************************

  Attributes:
   - name
   - width
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'width', None, None, ), # 2
  )

  def __init__(self, name=None, width=None,):
    self.name = name
    self.width = width

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.width = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ParserValueSetFieldDesc')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I32, 2)
      oprot.writeI32(self.width)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ParserValueSetEntry:
  """
  Attributes:
   - value
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
    (2, TType.STRING, 'mask', None, None, ), # 2
  )

  def __init__(self, value=None, mask=None,):
    self.value = value
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mask = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ParserValueSetEntry')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.STRING, 2)
      oprot.writeString(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ParserValueSetDesc:
  """
  Attributes:
   - pvs_id
   - pvs_name
   - pvs_entries_max
   - key_layout
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'pvs_id', None, None, ), # 1
    (2, TType.STRING, 'pvs_name', None, None, ), # 2
    (3, TType.I32, 'pvs_entries_max', None, None, ), # 3
    (4, TType.LIST, 'key_layout', (TType.STRUCT,(ParserValueSetFieldDesc, ParserValueSetFieldDesc.thrift_spec)), None, ), # 4
  )

  def __init__(self, pvs_id=None, pvs_name=None, pvs_entries_max=None, key_layout=None,):
    self.pvs_id = pvs_id
    self.pvs_name = pvs_name
    self.pvs_entries_max = pvs_entries_max
    self.key_layout = key_layout

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.pvs_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pvs_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.pvs_entries_max = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.key_layout = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = ParserValueSetFieldDesc()
            _elem19.read(iprot)
            self.key_layout.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ParserValueSetDesc')
    if self.pvs_id is not None:
      oprot.writeFieldBegin('pvs_id', TType.I32, 1)
      oprot.writeI32(self.pvs_id)
      oprot.writeFieldEnd()
    if self.pvs_name is not None:
      oprot.writeFieldBegin('pvs_name', TType.STRING, 2)
      oprot.writeString(self.pvs_name)
      oprot.writeFieldEnd()
    if self.pvs_entries_max is not None:
      oprot.writeFieldBegin('pvs_entries_max', TType.I32, 3)
      oprot.writeI32(self.pvs_entries_max)
      oprot.writeFieldEnd()
    if self.key_layout is not None:
      oprot.writeFieldBegin('key_layout', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.key_layout))
      for iter20 in self.key_layout:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pvs_id is None:
      raise TProtocol.TProtocolException(message='Required field pvs_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MeterCfg:
  """
  Attributes:
   - rate_k
   - burst_k
   - array_offset
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'rate_k', None, None, ), # 1
    (2, TType.I32, 'burst_k', None, None, ), # 2
    (3, TType.I32, 'array_offset', None, None, ), # 3
    (4, TType.I32, 'count', None, None, ), # 4
  )

  def __init__(self, rate_k=None, burst_k=None, array_offset=None, count=None,):
    self.rate_k = rate_k
    self.burst_k = burst_k
    self.array_offset = array_offset
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.rate_k = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.burst_k = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.array_offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MeterCfg')
    if self.rate_k is not None:
      oprot.writeFieldBegin('rate_k', TType.DOUBLE, 1)
      oprot.writeDouble(self.rate_k)
      oprot.writeFieldEnd()
    if self.burst_k is not None:
      oprot.writeFieldBegin('burst_k', TType.I32, 2)
      oprot.writeI32(self.burst_k)
      oprot.writeFieldEnd()
    if self.array_offset is not None:
      oprot.writeFieldBegin('array_offset', TType.I32, 3)
      oprot.writeI32(self.array_offset)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 4)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MeterDesc:
  """
  Attributes:
   - name
   - id
   - type
   - mclass
   - count
   - table
   - tableid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'id', None, None, ), # 2
    (3, TType.I32, 'type', None, None, ), # 3
    (4, TType.I32, 'mclass', None, None, ), # 4
    (5, TType.I32, 'count', None, None, ), # 5
    (6, TType.STRING, 'table', None, None, ), # 6
    (7, TType.I32, 'tableid', None, None, ), # 7
  )

  def __init__(self, name=None, id=None, type=None, mclass=None, count=None, table=None, tableid=None,):
    self.name = name
    self.id = id
    self.type = type
    self.mclass = mclass
    self.count = count
    self.table = table
    self.tableid = tableid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.mclass = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.tableid = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MeterDesc')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 2)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.mclass is not None:
      oprot.writeFieldBegin('mclass', TType.I32, 4)
      oprot.writeI32(self.mclass)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I32, 5)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 6)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.tableid is not None:
      oprot.writeFieldBegin('tableid', TType.I32, 7)
      oprot.writeI32(self.tableid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DigestFieldDesc:
  """
  ************************************************************
   Digests                                                    *
  ************************************************************

  Attributes:
   - name
   - width
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'width', None, None, ), # 2
  )

  def __init__(self, name=None, width=None,):
    self.name = name
    self.width = width

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.width = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DigestFieldDesc')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I32, 2)
      oprot.writeI32(self.width)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DigestDesc:
  """
  Attributes:
   - name
   - id
   - app_id
   - field_list_name
   - fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'id', None, None, ), # 2
    (3, TType.I32, 'app_id', None, None, ), # 3
    (4, TType.STRING, 'field_list_name', None, None, ), # 4
    (5, TType.LIST, 'fields', (TType.STRUCT,(DigestFieldDesc, DigestFieldDesc.thrift_spec)), None, ), # 5
  )

  def __init__(self, name=None, id=None, app_id=None, field_list_name=None, fields=None,):
    self.name = name
    self.id = id
    self.app_id = app_id
    self.field_list_name = field_list_name
    self.fields = fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.app_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.field_list_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.fields = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = DigestFieldDesc()
            _elem26.read(iprot)
            self.fields.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DigestDesc')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 2)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.app_id is not None:
      oprot.writeFieldBegin('app_id', TType.I32, 3)
      oprot.writeI32(self.app_id)
      oprot.writeFieldEnd()
    if self.field_list_name is not None:
      oprot.writeFieldBegin('field_list_name', TType.STRING, 4)
      oprot.writeString(self.field_list_name)
      oprot.writeFieldEnd()
    if self.fields is not None:
      oprot.writeFieldBegin('fields', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter27 in self.fields:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DebugCtlReturn:
  """
  ************************************************************
   Opaque debug interface                                     *
  ************************************************************

  Attributes:
   - return_value
   - return_data
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'return_value', None, None, ), # 1
    (2, TType.STRING, 'return_data', None, None, ), # 2
  )

  def __init__(self, return_value=None, return_data=None,):
    self.return_value = return_value
    self.return_data = return_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.return_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.return_data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DebugCtlReturn')
    if self.return_value is not None:
      oprot.writeFieldBegin('return_value', TType.I32, 1)
      oprot.writeI32(self.return_value)
      oprot.writeFieldEnd()
    if self.return_data is not None:
      oprot.writeFieldBegin('return_data', TType.STRING, 2)
      oprot.writeString(self.return_data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
